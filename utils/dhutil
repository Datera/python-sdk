#!/usr/bin/env python

from __future__ import print_function, division, unicode_literals
"""

dhutil:    Datera Host Utility

Usage:
    dhutil
        --basename <string>
        --template <string>
        --size <string> (GB)
        --count <int>
        --numreplicas <int>
        --cleanall
        --showall
        --mkfs
        --mpmap
        --dirprefix <string>
        --chown <string>
        --fstype <string>
        --createfio
        --snappol  <RETCOUNT> <SNAPINTERVAL>
        --volperf  <TOTAL_IOPS_MAX> <TOTAL_BANDWIDTH_MAX>
        --clone <APP_INSTANCE_NAME>
        --tenant <TENANT_NAME>
        --version

    'basename' corresponds to the app_instance
    'size' is interpreted as number of GB.
    'count' is the number of app_instances to create
    'numreplicas' is the number of replicas to create
    'template' must refer to an existing template
    'cleanall' applies only to a given 'basename'
    'showall' takes no other args/options
    'mkfs' will create ext4 file systems on the volumes created
    'mpmap' will show the hostside multipath volume mapping
    'dirprefix' specifies a mount point prefix for the volume mount
    'chown' specifies chown:chgrp for the mount point
    'fstype currently xfs (default) or ext4
    'createfio' creates sample fio files for each volume
    'snappol' specifies snapshot retention count and interval
    'volperf' volume-level total max iops and bandwidth
    'clone' clone a specified application instance
    'tenant' uses the specified tenant name for create application instances
    'version' specifies the current dhutil version and supported API version
"""
import sys
import os
import subprocess
import platform
import time
import argparse
import multiprocessing as mp
from dfs_sdk import DateraApi
from dfs_sdk import DateraApi21

SLEEP = 10
NUMREPLICAS = 3
DISK_BY_PATH = "/dev/disk/by-path"
SYS_BLOCK = "/sys/block"
CLONE_AI_LIST = []
try:
    VER = subprocess.check_output(["git", "describe", "--always"])
except subprocess.CalledProcessError:
    VER = "unknown"
API_VER = "2.1"

SUCCESS = 0
FAILURE = 1


def usage():
    print("""
Usage:
    dhutil
        --basename <string>
        --template <string>
        --size <string> (GB)
        --count <int>
        --numreplicas <int>
        --cleanall
        --showall
        --mkfs
        --mpmap
        --dirprefix <string>
        --chown <string>
        --fstype <string>
        --createfio
        --snappol  <RETCOUNT> <SNAPINTERVAL>
        --volperf  <TOTAL_IOPS_MAX> <TOTAL_BANDWIDTH_MAX>
        --clone <APP_INSTANCE_NAME>
        --tenant <TENANT_NAME>

    'basename' corresponds to the app_instance
    'size' is interpreted as number of GB.
    'count' is the number of app_instances to create
    'numreplicas' is the number of replicas to create
    'template' must refer to an existing template
    'cleanall' applies only to a given 'basename'
    'showall' takes no other args/options
    'mkfs' will create ext4 file systems on the volumes created
    'mpmap' will show the hostside multipath volume mapping
    'dirprefix' specifies a mount point prefix for the volume mount
    'chown' specifies chown:chgrp for the mount point
    'fstype currently xfs (default) or ext4
    'createfio' creates sample fio files for each volume
    'snappol' specifies snapshot retention count
              and interval(15min, 1hour, 1day, 1month, 1year)
    'volperf' volume-level total max iops and bandwidth(KBps)
    'clone' clones a specified application instance
    'tenant' uses the specified tenant name for create application instances


""")

    sys.exit(FAILURE)


def version():
    print("dhutil version:", VER)
    print("API version:", API_VER)
    sys.exit(0)

#
# Create Volume within a storage instance.
# Takes storage_instance as input parameter
#


def vol_create(si, name, args, api):
    if args.numreplicas:
        numreplicas = args.numreplicas
    else:
        numreplicas = NUMREPLICAS
    tenant = ''
    if args.tenant:
        tenant = "/root/" + args.tenant
    # if api.system.get()['sw_version'] > API_VER:
    if api.system.get()['sw_version'].startswith(API_VER):
        vol = si.volumes.create(name=name, size=int(
            args.size), replica_count=int(numreplicas), tenant=tenant)
        if args.snappol:
            vol.snapshot_policies.create(name=name, retention_count=int(
                args.snappol[0]), interval=args.snappol[1], tenant=tenant)
        if args.volperf:
            vol.performance_policy.create(total_iops_max=int(
                args.volperf[0]), total_bandwidth_max=int(args.volperf[1]),
                                                          tenant=tenant)
    else:
        vol = si.volumes.create(name=name, size=int(
            args.size), replica_count=int(numreplicas))
        if args.snappol:
            vol.snapshot_policies.create(name=name, retention_count=int(
                args.snappol[0]), interval=args.snappol[1])
        if args.volperf:
            vol.performance_policy.create(total_iops_max=int(
                args.volperf[0]), total_bandwidth_max=int(args.volperf[1]))

    return vol['uuid']


def initiator_create(api, name, id):
    iis = api.initiators.list()
    for i in iis:
        if i['id'] == id:
            print("Initiator: (%s) %s,  already exists" % (i['name'], id))
            return i
    print("Creating Initiator: (%s) %s" % (name, id))
    return api.initiators.create(name=name, id=id)


def run_cmd(cmd):
    print(cmd)
    os.system(cmd)


def target_logout_and_node_cleanup(api, node, basename):
    for ai in api.app_instances.list():
        for si in ai.storage_instances.list():
            if ai['name'].startswith(basename):
                # print si['access']['ips']
                if 'iqn' in si['access']:
                    run_cmd("iscsiadm -m node -u -T %s" % si['access']['iqn'])
                    run_cmd("iscsiadm -m node -T %s --op=delete" %
                            si['access']['iqn'])
                for ip in si['access']['ips']:
                    run_cmd(
                        "iscsiadm -m discoverydb -t st -p %s:3260"
                        "--op=delete" % ip)

    # Ubuntu and debian
    if platform.dist()[0] == 'Ubuntu':
        run_cmd("iscsiadm -m session --rescan")
        run_cmd("service multipath-tools reload")
    # rhel, centos, sles
    else:
        run_cmd("iscsiadm -m session --rescan")
        run_cmd("service multipathd reload")


def target_login(node, si, initiator, sleep=SLEEP):
    # Wait a bit ...
    if sleep != 0:
        print("Wait %s for storage to come online " % sleep)
        time.sleep(sleep)
    iqn = si['access']['iqn']
    print("IQN: " + iqn)
    for ip in si['access']['ips']:
        print("IP ADDRS = ", ip)
        cmd = "iscsiadm -m node -T {} --portal {} --op=new".format(iqn, ip)
        cmd = cmd + " > /dev/null 2>&1"
        run_cmd(cmd)
        cmd = "iscsiadm -m node -T {} --portal {} -l"
        run_cmd(cmd.format(iqn, ip))


def clean_all(api, target, args):
    # Check API Version
    if api.system.get()['sw_version'].startswith(API_VER):
        if args.tenant:
            tenantname = "/root/" + args.tenant
        else:
            tenantname = ''
        # Deleting app instances
        for app_instance in api.app_instances.list(tenant=tenantname):
            if not app_instance["name"].startswith(target):
                continue
            print("Delete app instance " + app_instance['name'])
            app_instance.set(admin_state="offline",
                             force=True, tenant=tenantname)
            app_instance.delete(tenant=tenantname)

        # Deleting initators
        for initiator in api.initiators.list():
            if not initiator["name"].startswith(target):
                continue
            print("Delete initiator " + initiator['name'])
            initiator.delete()

        # Deleting tenants
        if tenantname != '':
            for tenant in api.tenants.list():
                if tenant['path'] == '/tenants/root':
                    continue
                if not api.app_instances.list():
                    tenant.delete(tenant=tenantname)
                    print("Deleted tenant " + tenant['name'])
                else:
                    print("Tenant is not empty and hence was not deleted")

    else:
        for app_instance in api.app_instances.list():
            if not app_instance["name"].startswith(target):
                continue
            print("Delete app instance " + app_instance['name'])
            app_instance.set(admin_state="offline", force=True)
            app_instance.delete()

        for initiator in api.initiators.list():
            if not initiator["name"].startswith(target):
                continue
            print("Delete initiator " + initiator['name'])
            initiator.delete()


def sn_to_hostname(api, sn):
    # uuid = sn.split("/")[2]
    if api.system.get()['sw_version'].startswith(API_VER):
        uuid = sn['path'].split("/")[2]
    else:
        uuid = sn.split("/")[2]
    sn = api.storage_nodes.get(uuid)
    return sn['name']


def si_to_hostname(api, si):
    sn_name = 'undef'
    for sn in si['active_storage_nodes']:
        if api.system.get()['sw_version'].startswith(API_VER):
            uuid = sn['path'].split("/")[2]
        else:
            uuid = sn.split("/")[2]
        sn = api.storage_nodes.get(uuid)
        sn_name = 'undef'
        sn_name = sn['name']
    # todo, this only returns the last active server in the list
    return sn_name


def show_all(api):
    for at in api.app_templates.list():
        print("App_Template: " + at['name'])
    if api.system.get()['sw_version'].startswith(API_VER):
        for tenant in api.tenants.list():
            print("Tenant: " + tenant['name'])
            if tenant["name"] != "root":
                tenant = "/root/" + tenant["name"]
            else:
                tenant = "/" + tenant["name"]
            for ai in api.app_instances.list(tenant=tenant):
                print("  App_instance: " + ai['name'])
                print("    admin_state: ", ai['admin_state'])
                for si in ai.storage_instances.list(tenant=tenant):
                    print("    -Storage_instance: " + si['name'])
                    for i in si.acl_policy.initiators.list(tenant=tenant):
                        print("        +Initiators: %s  (%s)" % (
                            i['id'], i['name']))
                    if 'iqn' in si['access']:
                        print("        +IQN: " + si['access']['iqn'])
                    for ip in si['access']['ips']:
                        print("        +ACCESS IP: " + ip)
                    for sn in si['active_storage_nodes']:
                        print("        +ACTIVE_STORAGE_NODES: ",
                              sn_to_hostname(api, sn))
                    for v in si.volumes.list(tenant=tenant):
                        print("        =Volume: {},   Size : {},   UUID : {}"
                              "".format(v['name'], v['size'], v['uuid']))
    else:
        for ai in api.app_instances.list():
            print("App_instance: " + ai['name'])
            print("    admin_state: ", ai['admin_state'])
            for si in ai.storage_instances.list():
                print("    -Storage_instance: " + si['name'])
                for i in si.acl_policy.initiators.list():
                    print("        +Initiators: %s  (%s)" % (
                        i['id'], i['name']))
                if 'iqn' in si['access']:
                    print("        +IQN: " + si['access']['iqn'])
                for ip in si['access']['ips']:
                    print("        +ACCESS IP: " + ip)
                for sn in si['active_storage_nodes']:
                    print("        +ACTIVE_STORAGE_NODES: ",
                          sn_to_hostname(api, sn))
                for v in si.volumes.list():
                    print("        =Volume: {},   Size : {},   UUID : {}"
                          " ".format(v['name'], v['size'], v['uuid']))


def mkfs(args):
    if args[2].fstype == "ext4":
        cmd = ("mkfs.ext4 -E lazy_itable_init=1 {} ; mkdir -p /{}; mount {} "
               "/{}".format(args[0], args[1], args[0], args[1]))
    else:
        cmd = "mkfs.xfs {} ; mkdir -p /{}; mount {} /{}".format(
            args[0], args[1], args[0], args[1])
    print(cmd)
    os.system(cmd)
    if args[2].chown:
        os.system("chown -R {} /{}".format(args[2].chown, args[1]))


def uuid_to_dm(args, uuid):
    for f in os.listdir(DISK_BY_UUID):
        if uuid in f:
            return os.path.basename(os.readlink(DISK_BY_UUID + "/" + uuid))


def iqn_to_sd(args, iqn):
    for f in os.listdir(DISK_BY_PATH):
        if iqn in f:
            return os.path.basename(os.readlink(DISK_BY_PATH + "/" + f))


def sd_to_dm(sd):
    for f in os.listdir(SYS_BLOCK):
        t = SYS_BLOCK + "/" + f + "/" + "slaves" + "/" + sd
        if os.path.islink(t):
            return f


def dm_to_mapper(dm):
    fname = "{}/{}/dm/name".format(SYS_BLOCK, dm)
    with open(fname, 'r') as f:
        mapper = f.read().strip()
    f.closed
    return mapper


def mapper_to_dmpath(mapper):
    return "/dev/mapper/" + mapper


def map_def(api, args, basename):
    map = {}
    if args.clone:
        assert CLONE_AI_LIST, "clone list is EMPTY"
    else:
        if api.system.get()['sw_version'].startswith(API_VER):
            for t in api.tenants.list():
                t = t.reload()
                if t["name"] != "root":
                    tenant = "/root/" + t["name"]
                else:
                    tenant = "/" + t["name"]
                for ai in api.app_instances.list(tenant=tenant):
                    for si in ai['storage_instances']:
                        for v in si['volumes']:
                            id = v['uuid']
                            if not basename or basename in ai['name']:
                                map[id] = {'tname': t['name'],
                                           'aname': ai['name'],
                                           'sname': si['name'],
                                           'vname': v['name'],
                                           'id': id,
                                           'nodename': si_to_hostname(api, si)}
                                if 'iqn' in si['access']:
                                    map[id]['iqn'] = si['access']['iqn']
        else:
            for ai in api.app_instances.list():
                ai = ai.reload()
                for si in ai['storage_instances'].values():
                    for v in si['volumes'].values():
                        id = v['uuid']
                        if not basename or basename in ai['name']:
                            map[id] = {'aname': ai['name'],
                                       'sname': si['name'],
                                       'vname': v['name'],
                                       'id': id,
                                       'nodename': si_to_hostname(api, si)}
                            if 'iqn' in si['access']:
                                map[id]['iqn'] = si['access']['iqn']
    return map


def mpmap(api, args, tenant):
    mntmap = []
    basename = args.basename

    map = map_def(api, args, basename)

    for m in map:
        if args.volperf:
            print("Sleeping 3s for target to be discovered")
            time.sleep(3)
        sd = iqn_to_sd(args, map[m]['iqn'])
        if sd:
            dm = sd_to_dm(sd)
            if not dm:
                print("No DM for sd: {}. Please make sure that multipath "
                      "service is running. Then cleanall and retry".format(sd))
                sys.exit(FAILURE)
            mapper = dm_to_mapper(dm)
            if not mapper:
                print("No mapper entry for dm: {}. Please make sure that "
                      "multipath service is running. Then cleanall and "
                      "retry".format(dm))
                sys.exit(FAILURE)
            dmpath = mapper_to_dmpath(mapper)

            if api.system.get()['sw_version'].startswith(API_VER):
                print("HOST-DM: ", dm,
                      "   DATERA: ", map[m]['tname'], "/", map[m]['aname'],
                      "/", map[m]['sname'], "/", map[m]['vname'],
                      "   IQN: ", map[m]['iqn'],
                      "   MAPPER: /dev/mapper/", mapper,
                      "   NODE:", map[m]['nodename'])
            else:
                print("HOST-DM: ", dm,
                      "   DATERA: ", map[m]['aname'],
                      "/", map[m]['sname'], "/", map[m]['vname'],
                      "   IQN: ", map[m]['iqn'],
                      "   MAPPER: /dev/mapper/", mapper,
                      "   NODE:", map[m]['nodename'])

            if args.mkfs or args.clone:
                mntpoint = map[m]['aname'] + "-" + map[m]['vname']
                if args.dirprefix:
                    mntpoint = args.dirprefix + "/" + mntpoint
                mntmap.append([dmpath, mntpoint, args])

    if args.mkfs or args.clone:
        return mntmap
    else:
        return map


def create_fio_template():
    with open('fiotemplate.fio', 'w') as f:
        lines = ["[global]", "randrepeat=0", "ioengine=libaio", "iodepth=16",
                 "direct=1", "numjobs=4", "runtime=3600", "group_reporting",
                 "time_based"]
        for line in lines:
            f.write(line + '\n')


def create_fio_files(api, args, tenant):

    fio = {args.basename + '_randread.fio': {
            'rw': 'randread', 'blocksize': '4k'},
           args.basename + '_seqread.fio': {'rw': 'read', 'blocksize': '1m'},
           args.basename + '_randwrite.fio': {
               'rw': 'randwrite', 'blocksize': '4k'},
           args.basename + '_seqwrite.fio': {'rw': 'write', 'blocksize': '1m'},
           args.basename + '_randreadwrite.fio': {
               'rw': 'randrw', 'rwmixread': '70', 'blocksize': '4k'}
           }

    create_fio_template()
    mntmap = mpmap(api, args, tenant)

    for key, item in list(fio.items()):
        with open('fiotemplate.fio', 'r') as f:
            with open(key, 'w') as key:
                for line in f:
                    key.write(line)
                for param in item:
                    key.write(param + "=" + item[param] + '\n')
                if args.mkfs:
                    for index in range(len(mntmap)):
                        key.write("[fiofile]" + '\n')
                        key.write("directory=/" + mntmap[index][1] + '\n')
                        key.write("size=500M" + '\n')
                else:
                    for id in mntmap:
                        key.write("[fiofile]" + '\n')
                        sd = iqn_to_sd(args, mntmap[id]['iqn'])
                        if sd:
                            dm = sd_to_dm(sd)
                            key.write("filename=/dev/" + dm + '\n')
                            key.write("size=500M" + '\n')


def get_volume_id_and_path(api, app_instance):
    volume_map = {}
    ai = api.app_instances.get(app_instance['name'])
    for si in list(ai['storage_instances'].keys()):
        volume_map[si] = {}
        for vol in list(ai['storage_instances'][si]['volumes'].keys()):
            volume_map[si][vol] = {}
            volume_map[si][vol]['path'] = ai['storage_instances'][si][
                'volumes'][vol]['path']
            if 'acl_policy' in ai['storage_instances'][si]:
                volume_map[si][vol]['acl_policy'] = ai['storage_instances'][
                    si]['acl_policy']['initiators']
            if 'performance_policy' in ai['storage_instances'][si]['volumes'][
                    vol]:
                volume_map[si][vol]['performance_policy'] = ai[
                    'storage_instances'][si]['volumes'][vol][
                        'performance_policy']
            if 'snapshot_policies' in ai['storage_instances'][si]['volumes'][
                    vol]:
                volume_map[si][vol]['snapshot_policy'] = ai[
                    'storage_instances'][si]['volumes'][vol][
                        'snapshot_policies']
    return volume_map


def copy_snapshot_policy(new_app_instance, volume_map, si, vol):
    for snapid in volume_map[si][vol]['snapshot_policy']:
        name = volume_map[si][vol]['snapshot_policy'][snapid]['name']
        ret_count = volume_map[si][vol]['snapshot_policy'][snapid][
            'retention_count']
        start_time = volume_map[si][vol]['snapshot_policy'][snapid][
            'start_time']
        interval = volume_map[si][vol]['snapshot_policy'][snapid]['interval']
        new_app_instance.storage_instances.get(si).volumes.get(
                vol).snapshot_policies.create(
                    name=name, retention_count=ret_count,
                    start_time=start_time, interval=interval)


def clone_an_app_instance(api, args):
    clone_ai_list = []
    if api.system.get()['sw_version'].startswith(API_VER):
        print("cloning via dhutil is not yet supported in", api.system.get()[
            'sw_version'])
        sys.exit(FAILURE)
    else:
        for app_instance in api.app_instances.list():
            if app_instance["name"].startswith(args.basename):
                try:
                        # get volume id
                    volume_map = get_volume_id_and_path(api, app_instance)
                    for si in list(volume_map.keys()):
                        for vol in list(volume_map[si].keys()):
                                # clone app Intance with volume id as the new
                                # name
                            new_app_instance = api.app_instances.create(
                                name=app_instance['name'] + "_clone",
                                clone_src=volume_map[si][vol]['path'])
                            # copy acl policies
                            if 'acl_policy' in volume_map[si][vol]:
                                new_app_instance.storage_instances.get(
                                    si).acl_policy.set(
                                        initiators=[str(volume_map[si][
                                            vol]['acl_policy'][0])])
                                time.sleep(2)
                                if (new_app_instance.reload()[
                                    'storage_instances'][si]['op_state'] !=
                                        "available"):
                                    print("error copying acl_policies")
                                    sys.exit(FAILURE)
                                # add initiator groups
                            # copy performance policies
                            if 'performance_policy' in volume_map[si][vol]:
                                performance_policy = api.app_instances.get(
                                    app_instance[
                                        'name']).storage_instances.get(
                                            si).volumes.get(
                                        vol).performance_policy.list()[0]
                                new_app_instance.storage_instances.get(
                                    si).volumes.get(
                                            vol).performance_policy.create(
                                        total_iops_max=performance_policy[
                                            'total_iops_max'],
                                        total_bandwidth_max=performance_policy[
                                            'total_bandwidth_max'],
                                        read_iops_max=performance_policy[
                                            'read_iops_max'],
                                        read_bandwidth_max=performance_policy[
                                            'read_bandwidth_max'],
                                        write_iops_max=performance_policy[
                                            'write_iops_max'],
                                        write_bandwidth_max=performance_policy[
                                            'write_bandwidth_max'])
                                time.sleep(2)
                                if (new_app_instance.reload()[
                                    'storage_instances'][si]['op_state'] !=
                                        "available"):
                                    print("error copying performance_policies")
                                    sys.exit(FAILURE)
                            # copy snapshot policies
                            if 'snapshot_policy' in volume_map[si][vol]:
                                copy_snapshot_policy(
                                    new_app_instance, volume_map, si, vol)
                                time.sleep(2)
                                if (new_app_instance.reload()[
                                    'storage_instances'][si]['op_state'] !=
                                        "available"):
                                    print("error copying snapshot_policies")
                                    sys.exit(FAILURE)
                            print("cloned", app_instance['name'], "to",
                                  new_app_instance['name'])
                            state = api.app_instances.get(
                                new_app_instance["name"]).set(
                                    admin_state="online")
                            print("setting admin state of ",
                                  new_app_instance['name'], "to",
                                  state["admin_state"])
                            clone_ai_list.append(new_app_instance)
                except KeyError:
                    msg = "appInstance: [{}] doesn't exist".format(
                        app_instance['name'])
                    print(msg)
                    continue
    return clone_ai_list


def chktempl(api, templ):
    for at in api.app_templates.list():
        if at['name'] == templ:
            return True
    return False


def unmount(name):
    cmd = "mount |grep %s | awk '{print $3}'" % name
    for l in os.popen(cmd).readlines():
        line = l.rstrip()
        if line == "/":
            print("skipping unmount of /")
            return None
        p = os.path.basename(line)
        print(p)
        print(line)
        run_cmd("umount %s" % line)
        run_cmd("rm -rf %s" % line)
    # cleanup fio files
    run_cmd("rm -rf " + name + "*.fio")


def nocreds():
    print()
    print("Credentials needed of form 'user:password:IPAddr'")
    print("supplied in DTSCREDS environment variable")
    print()
    sys.exit(FAILURE)


def chk_args(args):

    # the only options allowed without basename
    if not args.basename and not args.showall and not args.mpmap:
        print("ERROR: most options require basename")
        usage()

    # need at least one of these
    if not args.basename and not args.showall and not args.mpmap:
        print("ERROR:  Need atleast 'basename', 'showall' or 'mpmap'")
        usage()

    # options required if basename
    if args.basename and not (args.template or args.count or
                              args.cleanall or args.mpmap or args.mkfs or
                              args.clone):
        print("ERROR: Missing required arguments for 'basename'")
        usage()

    # options not allowed with cleanall
    if args.cleanall and (args.size or args.count or args.showall or
                          args.mkfs or args.mpmap or args.dirprefix or
                          args.chown or args.template or
                          args.fstype or args.numreplicas):
        print("ERROR: 'cleanall' include extraneous options")
        usage()

    # option combinations required
    if args.count and not (args.size or args.template):
        print("ERROR: 'count' requires 'size' or 'template'")
        usage()

    if args.template and not args.count:
        print("ERROR: 'template' requires 'count'")
        usage()

    if args.fstype and not args.mkfs:
        print("ERROR: 'fstype' requires 'mkfs'")
        usage()

    # options not allowed together
    if (args.size or args.numreplicas) and args.template:
        print("ERROR: 'size' and 'numreplicas' not allowed with 'template'")
        usage()

    # options with specific required values
    if args.fstype and args.fstype not in ['ext4', 'xfs']:
        print("ERROR: Only 'xfs' and 'ext4' are allowed for fstype")
        usage()

    if args.snappol:
        if args.snappol[0].isdigit() is False:
            print("ERROR: RETCOUNT must be an integer")
            usage()
        if args.snappol[1] not in (
                '15min', '1hour', '1day', '1week', '1month', '1year'):
            print("ERROR: INTERVAL must be '15min' or '1hour' or '1day' or "
                  "'1week' or '1month' or '1year'")
            usage()

    if args.tenant == "root":
        print("ERROR: root is not an allowed value for the tenant argument")
        usage()


def iscsiadm_chk():
    try:
        subprocess.check_output(["iscsiadm", "--version"])
    except subprocess.CalledProcessError:
        print()
        print("iscsiadm not available.")
        print("Please install :")
        print("      RH/CentOS: 'yum install iscsi-initiator-utils'")
        print("      Ubuntu:    'apt-get install open-iscsi'")
        print()
        sys.exit(FAILURE)


def mpath_chk():
    try:
        subprocess.check_output(["multipath", "-v0", ])
    except subprocess.CalledProcessError:
        print()
        print("multipath not available.")
        print("Please install :")
        print("      RH/CentOS: 'yum install device-mapper-multipath'")
        print("      Ubuntu:    'apt-get install multipath-tools'")
        print()
        sys.exit(FAILURE)


def lsscsi_chk():
    try:
        subprocess.check_output(["lsscsi", "-t", ])
    except subprocess.CalledProcessError:
        print()
        print("lsscsi not available.")
        print("Please install :")
        print("      RH/CentOS: 'yum install lsscsi'")
        print("      Ubuntu:    'apt-get install lsscsi'")
        print()
        sys.exit(FAILURE)


def dbck():
    # Check for docker bug: https://github.com/docker/docker/issues/7101"
    try:
        subprocess.check_output(
            "grep sysfs /proc/mounts | grep ro", shell=True)
        try:
            subprocess.call("mount -o rw,remount sysfs /sys")
            sys.exit(SUCCESS)
        except subprocess.CalledProcessError:
            print("Encountered https://github.com/docker/docker/issues/7101")
            print("and cannot remount /sys.  Need to be root?")
            sys.exit(FAILURE)
    except subprocess.CalledProcessError:
        # sysfs is not mounted 'ro'
        pass


def op_state_poller(instance):
    count = 0
    while count < 10:
        if instance['op_state'] != 'available':
            time.sleep(1)
            count = count + 1
        if count > 9:
            print(instance['name'] + " did not become available in 10s")
            sys.exit(FAILURE)
        break


def main():

    parser = argparse.ArgumentParser(description='dhutil')
    parser.add_argument('--basename', action="store", dest="basename")
    parser.add_argument('--template', action="store", dest="template")
    parser.add_argument('--createfio', action="store_true")
    parser.add_argument('--size', action="store", dest="size")
    parser.add_argument('--count', action="store", dest='count', type=int)
    parser.add_argument('--numreplicas', action="store", dest='numreplicas',
                        type=int)
    parser.add_argument('--cleanall', action="store_true")
    parser.add_argument('--showall', action="store_true")
    parser.add_argument('--mkfs', action="store_true")
    parser.add_argument('--mpmap', action="store_true")
    parser.add_argument('--dirprefix', action="store", dest='dirprefix')
    parser.add_argument('--chown', action="store", dest='chown')
    parser.add_argument('--fstype', action="store", dest='fstype')
    parser.add_argument('--snappol', action="store", dest="snappol", nargs=2,
                        metavar=('RETCOUNT', 'INTERVAL'),
                        help='volume-level snapshot retention count and '
                             'interval')
    parser.add_argument('--volperf', action="store", dest="volperf", nargs=2,
                        metavar=('TOTAL_IOPS_MAX',
                                 'TOTAL_BANDWIDTH_MAX[KBps]'),
                        type=int,
                        help='volume-level iops and bandwidth policies')
    parser.add_argument('--clone', action="store_true",
                        help='clones app instances that start with basename')
    parser.add_argument('--tenant', action="store",
                        help='creates tenant with given name. If exists, uses '
                             'that tenant')
    parser.add_argument('--version', action="store_true",
                        help='Specifies the current dhutil version and '
                             'supported API version')
    args = parser.parse_args()

    if args.version:
        version()

    if (len(sys.argv) < 2):
        usage()

    dbck()
    iscsiadm_chk()
    mpath_chk()
    lsscsi_chk()

    creds = os.getenv("DTSCREDS")
    if not creds or creds == "":
        nocreds()
    user, password, ipaddr = creds.split(":")

    basename = args.basename

    if basename and len(basename) < 3:
        print("Validation Error:  %s : must be at least 3 chars" % basename)
        sys.exit(FAILURE)

    # Make sure args make sense
    chk_args(args)

    print("Connecting to : ", ipaddr)
    api = DateraApi(username=user, password=password, hostname=ipaddr)
    # check sw verstion, and if it is 2.1, import the 2.1 API
    if api.system.get()['sw_version'].startswith(API_VER):
        if args.tenant:
            api = DateraApi21(username=user, password=password,
                              hostname=ipaddr,
                              tenant="/root/" + args.tenant)
        else:
            api = DateraApi21(username=user, password=password,
                              hostname=ipaddr, tenant=None)

    host = os.uname()[1].split('.')[0]
    tenant = ''

    if args.cleanall:
        unmount(basename)
        target_logout_and_node_cleanup(api, host, basename)
        clean_all(api, basename, args)
        sys.exit(SUCCESS)

    if args.showall:
        show_all(api)
        if args.mpmap:
            mpmap(api, args, tenant)
        sys.exit(SUCCESS)

    if args.mpmap and not args.count:
        mpmap(api, args, tenant)
        sys.exit(SUCCESS)

    cmd = "grep '^InitiatorName' /etc/iscsi/initiatorname.iscsi"
    cmd = cmd + " | sed -e 's/InitiatorName=//'"
    iscsi_initiator = os.popen(cmd).read().strip()
    ii = initiator_create(api, host, iscsi_initiator)

    #
    # Semantics:  If a template exists, create args.count instances
    #             from that template.
    #             If a template does not exist, create args.count instances
    #             Assumes 1:1:1 ratio of AppInstance:StorageInstance:Volume
    # TODO:       Allow non-singleton configurations

    # Make sure template exists
    if args.template:
        if chktempl(api, args.template):
            # If API version > API_VER
            if api.system.get()['sw_version'].startswith(API_VER):
                if args.tenant:
                    for subtenant in api.tenants.list()[0]['subtenants']:
                        if subtenant.endswith(args.tenant):
                            print("Using prexisting subtenant " + args.tenant)
                            tenant = "/root/" + args.tenant
                    if tenant == '':
                        api.tenants.create(name=args.tenant)
                        print("Created subtenant: ", args.tenant)
                        tenant = "/root/" + args.tenant
                # Create N app_instances from the template
                for n in range(1, args.count + 1):
                    appname = "%s-%d" % (args.basename, n)
                    tname = "/app_templates/" + args.template
                    print("I got here")
                    ai = api.app_instances.create(
                        name=appname, app_template=tname, tenant=tenant)
                    print("I got here too")
                    print("Created app_instance: ", ai['name'])
                    for si in ai.storage_instances.list(tenant=tenant):
                        si.acl_policy.initiators.add(ii, tenant=tenant)
                # Login to the storage
                # get app instance status
                for ai in api.app_instances.list(tenant=tenant):
                    if args.basename in ai['name']:
                        for si in ai.storage_instances.list(tenant=tenant):
                            op_state_poller(si)
                            print(si['name'] + " is online")
                            target_login(host, si, iscsi_initiator, sleep=0)
                run_cmd("lsscsi -t")
            else:
                for n in range(1, args.count + 1):
                    appname = "%s-%d" % (args.basename, n)
                    tname = "/app_templates/" + args.template
                    ai = api.app_instances.create(
                        name=appname, app_template=tname)
                    print("Created app_instance: ", ai['name'])
                    for si in ai.storage_instances.list():
                        si.acl_policy.initiators.add(ii)
                # Login to the storage
                # get app instance status
                for ai in api.app_instances.list():
                    if args.basename in ai['name']:
                        for si in ai.storage_instances.list():
                            op_state_poller(si)
                            print(si['name'] + " is online")
                            target_login(host, si, iscsi_initiator, sleep=0)
                run_cmd("lsscsi -t")
        else:
            print(args.template, " : does not exist!")
            sys.exit(FAILURE)
    elif args.count:
        #
        # Create N app_instances, storage_instance, and add initiator
        #
        if api.system.get()['sw_version'].startswith(API_VER):
            #
            # Create N app_instances, storage_instance, and add initiator
            #
            if args.tenant:
                for subtenant in api.tenants.list()[0]['subtenants']:
                    if subtenant.endswith(args.tenant):
                        print("Using prexisting subtenant " + args.tenant)
                        tenant = "/root/" + args.tenant
                if tenant == '':
                    api.tenants.create(name=args.tenant)
                    print("Created subtenant: ", args.tenant)
                    tenant = "/root/" + args.tenant
            for i in range(1, args.count + 1):
                bname = "{}_{}".format(basename, i)
                ai = api.app_instances.create(name=bname, tenant=tenant)
                si = ai.storage_instances.create(name=bname, tenant=tenant)
                si.acl_policy.initiators.add(ii, tenant=tenant)
                volname = "{}_vol".format(bname)
                uuid = vol_create(si, volname, args, api)
                print("Created Volume: %s (%s)" % (volname, uuid))
            for ai in api.app_instances.list(tenant=tenant):
                if basename in ai['name']:
                    # Wait until storage instance is online
                    for si in ai.storage_instances.list(tenant=tenant):
                        op_state_poller(si)
                        print(si['name'] + " is online")
                        target_login(host, si, iscsi_initiator, sleep=0)
        else:
            for i in range(1, args.count + 1):
                bname = "{}_{}".format(basename, i)
                ai = api.app_instances.create(name=bname)
                si = ai.storage_instances.create(name=bname)
                si.acl_policy.initiators.add(ii)
                volname = "{}_vol".format(bname)
                uuid = vol_create(si, volname, args, api)
                print("Created Volume: %s (%s)" % (volname, uuid))

            for ai in api.app_instances.list():
                if basename in ai['name']:
                    # Wait until storage instance is online
                    for si in ai.storage_instances.list():
                        op_state_poller(si)
                        print(si['name'] + " is online")
                        target_login(host, si, iscsi_initiator, sleep=0)

        run_cmd("lsscsi -t")

    if args.createfio:
        create_fio_files(api, args, tenant)

    if args.clone:
        cmd = "mount |grep " + args.basename
        global CLONE_AI_LIST
        CLONE_AI_LIST = clone_an_app_instance(api, args)

        # discover cloned volumes and login
        for ai in api.app_instances.list():
            if (ai['name'].startswith(args.basename) and
                    ai["name"].endswith("clone")):
                si = ai.storage_instances.list()[0]
                target_login(host, si, iscsi_initiator, sleep=0)

        run_cmd("lsscsi -t")
        mntmap = mpmap(api, args, tenant)

        try:
            output = subprocess.check_output(cmd, shell=True)
            if args.basename in output:
                for item in mntmap:
                    if "xfs" in output:
                        cmd = "mkdir -p /{}; mount -o nouuid {} /{}".format(
                            item[1], item[0], item[1])
                    else:
                        cmd = "mkdir -p /{}; mount {} /{}".format(
                            item[1], item[0], item[1])
                    print("mounting " + item[1])
                    os.system(cmd)
                    if item[2].chown:
                        os.system(
                            "chown -R {} /{}".format(item[2].chown, item[1]))
        except subprocess.CalledProcessError as e:
            print(str(e), "\n", basename,
                  "are block devices without filesystems. Cannot mount clone.")
            pass

    if args.mkfs:
        mntmap = mpmap(api, args, tenant)
        pool = mp.Pool()
        list(pool.imap_unordered(mkfs, mntmap))
    return 0


if __name__ == '__main__':
    sys.exit(main())
